function struct(name, schema, count, bytes) {
  this.name = name
  this.schema = schema
  this.bytes = bytes || 0
  for (let index = 1; index < schema.length; index += 2) {
    this.bytes += schema[index].getSize()
  }
  this.count = count || 1
  this.encoder = struct.encoder
  this.decoder = struct.decoder
}

// instance members
struct.prototype.setEncoder = function (f) {
  this.encoder = f
  return this
}

struct.prototype.setDecoder = function (f) {
  this.decoder = f
  return this
}

struct.prototype.setIsNoArray = function (noArray) {
  this.isNoArray = noArray
  return this
}

struct.prototype.forEachInSchema = function (f) {
  for (let index = 0; index < this.schema.length; index += 2) {
    const name = this.schema[index]
    const type = this.schema[index + 1]
    f(name, type)
  }
}

struct.prototype.getSize = function () {
  return this.bytes * this.count
}

struct.prototype.toString = function () {
  let out = ['struct ' + this.name + ' {']
  this.forEachInSchema((name, type) => {
    const array = type.count > 1 ? '[' + type.count + ']' : ''
    out.push('  ' + type.name + ' ' + name + array + '; // Size: ' + type.getSize())
  })
  out.push('}; // Size: ' + this.getSize())
  return out.join('\n')
}

struct.prototype.encode = function (buffer, pos, data, opt) {
  this.encoder(buffer, pos || 0, data, opt)
}

struct.prototype.decode = function (buffer, pos, opt) {
  return this.decoder(buffer, pos || 0, opt)
}

// class members
struct.encoder = function (buffer, pos, data, opt) {
  this.forEachInSchema((name, type) => {
    const dval = data && data[name]
    for (let index = 0; index < type.count; index += 1) {
      const element = dval && dval.join ? dval[index] : dval
      type.encode(buffer, pos, element, opt)
      if (type.isNoArray) {
        pos += type.getSize()
        break
      } else {
        pos += type.bytes
      }
    }
  })
}

struct.decoder = function (buffer, pos, opt) {
  const data = {}
  this.forEachInSchema((name, type) => {
    if (type.count === 1 || type.isNoArray) {
      data[name] = type.decode(buffer, pos, opt)
      pos += type.getSize()
    } else {
      let array = []
      data[name] = array
      for (let index = 0; index < type.count; index += 1) {
        array[index] = type.decode(buffer, pos, opt)
        pos += type.bytes
      }
    }
  })
  return data
}

struct.type = function (type, size, count) {
  if (type.getSize && count === undefined) {
    count = size
    size = type.getSize()
  }
  return new struct(type.name || type, [], count, size)
    .setEncoder(
      (buffer, pos, data, opt) => {
        type.encode(buffer, pos, data, opt)
      }
    )
    .setDecoder(
      (buffer, pos, opt) => {
        return type.decode(buffer, pos, opt)
      }
    )
}
struct.char = function (n) {
  return this.type('char', 1, n)
    .setIsNoArray(true)
    .setEncoder(
      (buffer, pos, data) => {
        const string = data ? data.toString() : ''
        for (let index = 0; index < n; index += 1) {
          buffer.write(index < string.length ? string[index] : '\0', pos + index)
        }
      }
    )
    .setDecoder(
      (buffer, pos) => {
        const s = buffer.toString('ascii', pos, pos + n)
        const cutAt = s.indexOf('\0')
        if (cutAt < 0) return s
        return s.slice(0, cutAt)
      }
    )
}

struct.toHeaderString = function (list) {
  const d = new Date()
  const date = d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate() + ' ' + d.getHours() + ':' + d.getMinutes()
  const out = ['// AUTOGENERATED CODE BY cpp-struct.js @ ' + date]
  for (const element of list) {
    out.push('struct ' + element.name + ';')
  }
  out.push('')
  for (let index = 0; index < list.length; index += 1)
    out.push(list[index].toString(), '')
  out.push('// check if sizes are as expected - if the compiler errors here',
    '// with a negative array size complaint, it means that the javascript',
    '// struct definitions are not matching the memory alignment of your',
    '// compiler. Insert placeholder elements to match the sizes.',
    '// Don\'t deactivate the tests! As long as the sizes differ, ',
    '// encoding and decoding will give wrong results!',
    '')
  for (const s of list) {
    out.push('typedef char _CheckSizeOf' + s.name +
      '_[sizeof(' + s.name + ') == ' + s.getSize() + ' ? 1 : -1];')
  }
  return out.join('\n')
}

function addNumberType(jsName, bytes, alias, aliasCPP) {
  const writeName = 'write' + jsName
  const readName = 'read' + jsName
  const writeAccess = [
    bytes > 1 ? writeName + 'BE' : writeName,
    bytes > 1 ? writeName + 'LE' : writeName
  ]
  const readAccess = [
    bytes > 1 ? readName + 'BE' : readName,
    bytes > 1 ? readName + 'LE' : readName
  ]

  if (!alias) alias = jsName.toLowerCase()
  struct[alias] = function (n) {
    return this.type(aliasCPP || (jsName.toLowerCase() + '_t'), bytes, n)
      .setEncoder(
        (buffer, pos, data, opt) => {
          buffer[writeAccess[opt && opt.endian === 'LE' ? 1 : 0]](data || 0, pos)
        }
      )
      .setDecoder(
        (buffer, pos, opt) => {
          return buffer[readAccess[opt && opt.endian === 'LE' ? 1 : 0]](pos)
        }
      )
  }
}

addNumberType('UInt8', 1, 'uint8_t')
addNumberType('UInt16', 2, 'uint16_t')
addNumberType('UInt32', 4, 'uint32_t')
addNumberType('Int8', 1, 'int8_t')
addNumberType('Int16', 2, 'int16_t')
addNumberType('Int32', 4, 'int32_t')
addNumberType('Float', 4, 'float32', 'float')
addNumberType('Double', 8, 'double64', 'double')

module.exports = struct
